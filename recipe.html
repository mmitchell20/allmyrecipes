<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Recipe — allmyrecipes</title>
<link rel="stylesheet" href="theme.css" />
<style>
  :root { --radius:12px; --blue:#006cff; }

  body{
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif;
    max-width:980px;margin:40px auto;padding:0 16px;line-height:1.5
  }
  nav{display:flex;gap:12px;margin-bottom:14px}
  nav a{padding:6px 10px;border:1px solid #eee;border-radius:8px;text-decoration:none;color:#111}
  h1{margin:.25rem 0 .5rem;font-size:1.6rem}
  .muted{color:#666}

  .prompt{ margin:10px 0 8px; font-weight:600; }
  .mode{ display:inline-block;background:#eef4ff;color:#0b57d0;border:1px solid #cddcff;border-radius:999px;padding:2px 8px;font-size:.85rem;margin-left:8px }

  /* Editable box */
  .editor{
    background:#fff;border:1px solid #ddd;border-radius:12px;
    padding:14px;min-height:320px;
    white-space: pre-wrap; outline:none;
    font-family:ui-monospace,Menlo,Consolas,monospace;
    color:#111; position:relative;
    transition: background-position .6s ease, color .2s ease, opacity .15s ease;
  }
  /* New inserts stay blue UNTIL you save */
  .editor .added{ color: var(--blue); }

  /* Shimmer on save */
  .editor.saving{
    background-image: linear-gradient(90deg, rgba(255,255,255,0) 0%,
                                             rgba(255,255,255,.7) 50%,
                                             rgba(255,255,255,0) 100%);
    background-size: 220% 100%;
    animation: amrShimmer .7s ease-out 1;
  }
  @keyframes amrShimmer{
    0% { background-position: -120% 0; }
    100% { background-position: 120% 0; }
  }

  .actions{display:flex;gap:10px;flex-wrap:wrap;margin-top:12px}
  button{padding:10px 14px;border:0;border-radius:12px;background:#111;color:#fff;cursor:pointer;display:inline-flex;align-items:center;gap:8px}
  button[disabled]{opacity:.6;cursor:not-allowed}
  .icon{width:18px;height:18px;display:inline-block;line-height:0}
  .hint{ color:#666;margin-top:6px }
</style>
</head>
<body>
  <nav>
    <a href="index.html">Home</a>
    <a href="cookbook.html">Your Cookbook</a>
  </nav>

  <h1>Cleaned recipe</h1>
  <div class="prompt">
    Any special touches or notes to add?
    <span class="mode">New typing shows in blue (until you Save)</span>
  </div>

  <div id="editor" class="editor" contenteditable="true" spellcheck="true"></div>
  <div class="hint">Type anywhere to tweak. Paste works too.</div>

  <div class="actions">
    <button id="save">
      <span class="icon" aria-hidden="true">
        <!-- checkmark cloud-ish save icon -->
        <svg viewBox="0 0 24 24" fill="currentColor"><path d="M19 18a4 4 0 0 0 0-8h-.3A6.5 6.5 0 0 0 6 9.5v.1A4.5 4.5 0 0 0 7.5 18H19zM11 13.5l-1.8 1.8-1.4-1.4 3.2-3.2L16 15.7l-1.4 1.4L11 13.5z"/></svg>
      </span>
      Save + add to cookbook
    </button>

    <button id="revert" type="button" title="Revert to original (preview)">
      <span class="icon" aria-hidden="true">
        <!-- history/clockwise arrow icon -->
        <svg viewBox="0 0 24 24" fill="currentColor"><path d="M12 5a7 7 0 1 1-4.95 2.05L5 5h5v5L8.94 8.94A5 5 0 1 0 17 12a1 1 0 1 1 2 0 7 7 0 0 1-7 7 7 7 0 1 1 0-14z"/></svg>
      </span>
      Revert to original
    </button>

    <button id="showUpdated" type="button" style="display:none">
      <!-- right-turn arrow icon -->
      <span class="icon" aria-hidden="true">
        <svg viewBox="0 0 24 24" fill="currentColor"><path d="M13 7l5 5-5 5V7zM4 5h6v2H6v10h4v2H4V5z"/></svg>
      </span>
      Updated
    </button>

    <span id="status" class="muted" style="align-self:center"></span>
  </div>

<script>
(function(){
  const editor = document.getElementById('editor');
  const saveBtn = document.getElementById('save');
  const revertBtn = document.getElementById('revert');
  const showUpdatedBtn = document.getElementById('showUpdated');
  const statusEl = document.getElementById('status');

  /* ---------- Build cleaned text from sessionStorage ---------- */
  function buildTxt(r){
    const ingredients = (r.ingredients||[]).map(x=>'• '+x).join('\n');
    const steps = (r.steps||[]).map((x,i)=> `${i+1}. ${x}`).join('\n');
    let t = `Title: ${r.title || ''}\n`;
    if (r.source) t += `Source: ${r.source}\n`;
    t += `\nIngredients:\n${ingredients}\n\nSteps:\n${steps}`;
    if (r.servings) t += `\n\nServings: ${r.servings}`;
    t += `\n\nNotes:\n`;
    return t;
  }
  function buildTxtFromRecipe(r){
    const ingredients = (r.ingredients||[]).map(x=>'• '+x).join('\n');
    const steps = (r.steps||[]).map((x,i)=> `${i+1}. ${x}`).join('\n');
    let t = `Title: ${r.title||''}\n`;
    if (r.source) t += `Source: ${r.source}\n`;
    t += `\nIngredients:\n${ingredients}\n\nSteps:\n${steps}`;
    if (r.servings) t += `\n\nServings: ${r.servings}`;
    if ((r.notes||'').trim()) t += `\n\nNotes:\n${r.notes}`;
    else t += `\n\nNotes:\n`;
    return t;
  }
  function esc(s){return s.replace(/[&<>"]/g,c=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;' }[c]));}
  function toHTML(text){ return esc(text).replace(/\n/g,'<br>'); }

  let recipe = null;
  try { recipe = JSON.parse(sessionStorage.getItem('amr_tmp')||'null'); } catch {}
  if (!recipe){
    document.body.innerHTML = `<nav>
        <a href="index.html">Home</a>
        <a href="cookbook.html">Your Cookbook</a>
      </nav>
      <p>Hmm, I can’t find a cleaned recipe to edit. Try <a href="index.html">pasting again</a>.</p>`;
    return;
  }

  const ORIGINAL_HTML = toHTML(buildTxt(recipe));
  editor.innerHTML = ORIGINAL_HTML;

  /* ---------- Editing: keep new inserts BLUE until Save ---------- */
  function setCaretAfter(node){
    const sel = window.getSelection();
    const range = document.createRange();
    range.setStartAfter(node);
    range.setEndAfter(node);
    sel.removeAllRanges();
    sel.addRange(range);
  }

  function insertBlue(text){
    const sel = window.getSelection();
    if (!sel.rangeCount) return;
    const range = sel.getRangeAt(0);
    range.deleteContents();

    const parts = (text||'').split(/\r?\n/);
    const frag = document.createDocumentFragment();
    parts.forEach((chunk, idx)=>{
      const span = document.createElement('span');
      span.className = 'added';
      span.textContent = chunk;
      frag.appendChild(span);
      if (idx < parts.length - 1) frag.appendChild(document.createElement('br'));
    });

    range.insertNode(frag);
    const marker = document.createElement('span');
    range.collapse(false);
    range.insertNode(marker);
    setCaretAfter(marker);
    marker.remove();
  }

  editor.addEventListener('beforeinput', (e)=>{
    if (e.inputType === 'insertText' && e.data) {
      e.preventDefault();
      insertBlue(e.data);
    } else if (e.inputType === 'insertLineBreak') {
      e.preventDefault();
      insertBlue('\n');
    }
  });
  editor.addEventListener('paste', (e)=>{
    e.preventDefault();
    const text = (e.clipboardData || window.clipboardData).getData('text');
    insertBlue(text);
  });
  editor.addEventListener('drop', (e)=> e.preventDefault());

  /* ---------- Save → shimmer → commit blue to black → store in Cookbook ---------- */
  const STORE_KEY='amr_cb_v1';
  function loadCookbook(){ try{return JSON.parse(localStorage.getItem(STORE_KEY)||'[]');}catch{return[];} }
  function saveCookbook(a){ localStorage.setItem(STORE_KEY, JSON.stringify(a)); }

  function editorToText(){ return editor.innerText.replace(/\u00A0/g,' ').trimEnd(); }

  function parseStructured(full){
    const get = (re) => { const m = full.match(re); return m ? m[1].trim() : ''; };
    const title   = get(/^Title:\s*(.*)$/m) || (recipe.title||'Untitled');
    const source  = get(/^Source:\s*(.*)$/m);
    const ingBlock = get(/^\s*Ingredients:\s*\n([\s\S]*?)(?:\n(?:Steps:|Servings:|Notes:)|$)/m);
    const ingredients = (ingBlock||'').split('\n').map(s=>s.trim()).filter(Boolean)
      .map(s=>s.replace(/^\s*[•*\-]?\s*\d{0,3}[.)]?\s*/,''));
    const stepsBlock = get(/^\s*Steps:\s*\n([\s\S]*?)(?:\n(?:Servings:|Notes:)|$)/m);
    const steps = (stepsBlock||'').split('\n').map(s=>s.trim()).filter(Boolean)
      .map(s=> s.replace(/^\s*\d{1,3}[.)]\s*/,''));
    const servings = get(/^Servings:\s*(.*)$/m);
    const notesBlock = get(/^\s*Notes:\s*\n([\s\S]*)$/m);
    const notes = notesBlock || '';
    return { title, source, ingredients, steps, servings, notes };
  }

  function commitAdditionsToBlack(){
    editor.querySelectorAll('.added').forEach(span=>{
      span.replaceWith(document.createTextNode(span.textContent));
    });
  }

  saveBtn.addEventListener('click', ()=>{
    saveBtn.disabled = true; revertBtn.disabled = true; showUpdatedBtn.disabled = true;

    editor.classList.add('saving');          // shimmer
    commitAdditionsToBlack();                // blue → black

    const finalText = editorToText();
    const parsed = parseStructured(finalText);

    const nowISO = new Date().toISOString();
    const rec = {
      id: recipe.id && recipe.id.startsWith('r_') ? recipe.id : 'r_'+Date.now()+'_'+Math.random().toString(36).slice(2,7),
      createdAt: recipe.createdAt || nowISO,
      ...recipe,
      ...parsed,
    };

    const items = loadCookbook();
    const idxById = items.findIndex(x => x.id === rec.id);
    const idxByTitle = items.findIndex(x => x.title.toLowerCase() === rec.title.toLowerCase());

    if (idxById >= 0)       items[idxById] = rec;
    else if (idxByTitle>=0){ rec.id = items[idxByTitle].id; items[idxByTitle] = rec; }
    else                    items.unshift(rec);

    saveCookbook(items);
    sessionStorage.setItem('amr_last_saved_title', rec.title);

    statusEl.textContent = 'Saved to your cookbook.';
    setTimeout(()=> {
      editor.classList.remove('saving');
      saveBtn.disabled = false; revertBtn.disabled = false; showUpdatedBtn.disabled = false;
    }, 750);
  });

  /* ---------- Revert preview + Updated toggle ---------- */
  let previewingOriginal = false;
  let workingHTML = editor.innerHTML; // current editable state (with blue spans)

  function loadLatestSavedHTML(){
    const items = loadCookbook();
    const lastTitle = (sessionStorage.getItem('amr_last_saved_title') || recipe.title || '').toLowerCase();
    const saved = items.find(r => (r.title||'').toLowerCase() === lastTitle);
    if (!saved) return null;
    return toHTML(buildTxtFromRecipe(saved));
  }

  revertBtn.addEventListener('click', ()=>{
    if (previewingOriginal) return;

    // keep current editor view to return to (working or saved later)
    workingHTML = editor.innerHTML;

    // show original baseline, read-only
    editor.innerHTML = ORIGINAL_HTML;
    editor.setAttribute('contenteditable','false');
    saveBtn.disabled = true;
    showUpdatedBtn.style.display = 'inline-flex';

    statusEl.textContent = 'Viewing original (not saved).';
    previewingOriginal = true;
  });

  showUpdatedBtn.addEventListener('click', ()=>{
    // Try most recent SAVED version first
    const savedHTML = loadLatestSavedHTML();
    if (savedHTML) {
      editor.innerHTML = savedHTML;
    } else {
      // fallback to whatever you were working on before preview
      editor.innerHTML = workingHTML;
    }

    editor.setAttribute('contenteditable','true');
    saveBtn.disabled = false;
    showUpdatedBtn.style.display = 'none';
    statusEl.textContent = 'Showing updated version.';
    setTimeout(()=> statusEl.textContent = '', 1200);
    previewingOriginal = false;
  });

})();
</script>
</body>
</html>
