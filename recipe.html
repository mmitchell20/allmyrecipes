<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Recipe — allmyrecipes</title>
<link rel="stylesheet" href="theme.css" />
<style>
  :root { --radius:12px; --blue:#006cff; }

  body{
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif;
    max-width:980px;margin:40px auto;padding:0 16px;line-height:1.5
  }
  nav{display:flex;gap:12px;margin-bottom:14px}
  nav a{padding:6px 10px;border:1px solid #eee;border-radius:8px;text-decoration:none;color:#111}
  h1{margin:.25rem 0 .5rem;font-size:1.6rem}
  .muted{color:#666}

  .prompt{ margin:10px 0 8px; font-weight:600; }
  .mode{ display:inline-block;background:#eef4ff;color:#0b57d0;border:1px solid #cddcff;border-radius:999px;padding:2px 8px;font-size:.85rem;margin-left:8px }

  /* Editable box */
  .editor{
    background:#fff;border:1px solid #ddd;border-radius:12px;
    padding:14px;min-height:320px;
    white-space: pre-wrap; outline:none;
    font-family:ui-monospace,Menlo,Consolas,monospace;
    color:#111; position:relative;
    transition: background-position .6s ease, color .2s ease;
  }
  /* New inserts stay blue UNTIL you save */
  .editor .added{ color: var(--blue); }

  /* Revert effect (when no .added present): tint everything blue briefly */
  .editor.revert-all{ color: var(--blue) !important; }

  /* Shimmer on save */
  .editor.saving{
    background-image: linear-gradient(90deg, rgba(255,255,255,0) 0%,
                                             rgba(255,255,255,.7) 50%,
                                             rgba(255,255,255,0) 100%);
    background-size: 220% 100%;
    animation: amrShimmer .7s ease-out 1;
  }
  @keyframes amrShimmer{
    0% { background-position: -120% 0; }
    100% { background-position: 120% 0; }
  }

  .actions{display:flex;gap:10px;flex-wrap:wrap;margin-top:12px}
  button{padding:10px 14px;border:0;border-radius:12px;background:#111;color:#fff;cursor:pointer}
  button[disabled]{opacity:.6;cursor:not-allowed}
  .hint{ color:#666;margin-top:6px }
</style>
</head>
<body>
  <nav>
    <a href="index.html">Home</a>
    <a href="cookbook.html">Your Cookbook</a>
  </nav>

  <h1>Cleaned recipe</h1>
  <div class="prompt">
    Any special touches or notes to add?
    <span class="mode">New typing shows in blue (until you Save)</span>
  </div>

  <div id="editor" class="editor" contenteditable="true" spellcheck="true"></div>
  <div class="hint">Type anywhere to tweak. Paste works too.</div>

  <div class="actions">
    <button id="save">Save + add to cookbook</button>
    <button id="revert" type="button">Revert to original</button>
    <span id="status" class="muted" style="align-self:center"></span>
  </div>

<script>
(function(){
  const editor = document.getElementById('editor');
  const saveBtn = document.getElementById('save');
  const revertBtn = document.getElementById('revert');
  const statusEl = document.getElementById('status');

  /* ---------- Build “cleaned” text from sessionStorage (set by index.html) ---------- */
  function buildTxt(r){
    const ingredients = (r.ingredients||[]).map(x=>'• '+x).join('\n');
    const steps = (r.steps||[]).map((x,i)=> `${i+1}. ${x}`).join('\n');
    let t = `Title: ${r.title || ''}\n`;
    if (r.source) t += `Source: ${r.source}\n`;
    t += `\nIngredients:\n${ingredients}\n\nSteps:\n${steps}`;
    if (r.servings) t += `\n\nServings: ${r.servings}`;
    t += `\n\nNotes:\n`; // space for your touches
    return t;
  }
  function esc(s){return s.replace(/[&<>"]/g,c=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;' }[c]));}

  let recipe = null;
  try { recipe = JSON.parse(sessionStorage.getItem('amr_tmp')||'null'); } catch {}
  if (!recipe){
    document.body.innerHTML = `<nav>
        <a href="index.html">Home</a>
        <a href="cookbook.html">Your Cookbook</a>
      </nav>
      <p>Hmm, I can’t find a cleaned recipe to edit. Try <a href="index.html">pasting again</a>.</p>`;
    return;
  }

  const originalText = buildTxt(recipe);
  const originalHTML = esc(originalText).replace(/\n/g,'<br>');
  editor.innerHTML = originalHTML;

  // Keep the untouched original for Revert
  const ORIGINAL_HTML = originalHTML;

  /* ---------- Editing: keep new inserts BLUE until Save ---------- */
  function setCaretAfter(node){
    const sel = window.getSelection();
    const range = document.createRange();
    range.setStartAfter(node);
    range.setEndAfter(node);
    sel.removeAllRanges();
    sel.addRange(range);
  }

  function insertBlue(text){
    const sel = window.getSelection();
    if (!sel.rangeCount) return;
    const range = sel.getRangeAt(0);
    range.deleteContents();

    const parts = (text||'').split(/\r?\n/);
    const frag = document.createDocumentFragment();
    parts.forEach((chunk, idx)=>{
      const span = document.createElement('span');
      span.className = 'added';
      span.textContent = chunk;
      frag.appendChild(span);
      if (idx < parts.length - 1) frag.appendChild(document.createElement('br'));
    });

    range.insertNode(frag);
    // place caret after what we inserted
    const marker = document.createElement('span');
    range.collapse(false);
    range.insertNode(marker);
    setCaretAfter(marker);
    marker.remove();
  }

  // Wrap typed characters and pasted text as .added (blue)
  editor.addEventListener('beforeinput', (e)=>{
    if (e.inputType === 'insertText' && e.data) {
      e.preventDefault();
      insertBlue(e.data);
    } else if (e.inputType === 'insertLineBreak') {
      e.preventDefault();
      insertBlue('\n');
    }
    // allow deletes/formatting changes to pass through
  });
  editor.addEventListener('paste', (e)=>{
    e.preventDefault();
    const text = (e.clipboardData || window.clipboardData).getData('text');
    insertBlue(text);
  });
  editor.addEventListener('drop', (e)=> e.preventDefault());

  /* ---------- Save → shimmer → commit blue to black → store in Cookbook ---------- */
  const STORE_KEY='amr_cb_v1';
  function loadCookbook(){ try{return JSON.parse(localStorage.getItem(STORE_KEY)||'[]');}catch{return[];} }
  function saveCookbook(a){ localStorage.setItem(STORE_KEY, JSON.stringify(a)); }

  // Turn the editor HTML into plain text with line breaks
  function editorToText(){
    // innerText preserves line breaks across <br>
    return editor.innerText.replace(/\u00A0/g,' ').trimEnd();
  }

  // Parse the flat text back to structured fields
  function parseStructured(full){
    const get = (re) => {
      const m = full.match(re);
      return m ? m[1].trim() : '';
    };
    const title   = get(/^Title:\s*(.*)$/m) || (recipe.title||'Untitled');
    const source  = get(/^Source:\s*(.*)$/m);

    // ingredients
    const ingBlock = get(/^\s*Ingredients:\s*\n([\s\S]*?)(?:\n(?:Steps:|Servings:|Notes:)|$)/m);
    const ingredients = (ingBlock||'').split('\n').map(s=>s.trim()).filter(Boolean)
      .map(s=>s.replace(/^\s*[•*\-]?\s*\d{0,3}[.)]?\s*/,''));

    // steps
    const stepsBlock = get(/^\s*Steps:\s*\n([\s\S]*?)(?:\n(?:Servings:|Notes:)|$)/m);
    const steps = (stepsBlock||'').split('\n').map(s=>s.trim()).filter(Boolean)
      .map(s=> s.replace(/^\s*\d{1,3}[.)]\s*/,''));

    const servings = get(/^Servings:\s*(.*)$/m);
    const notesBlock = get(/^\s*Notes:\s*\n([\s\S]*)$/m);
    const notes = notesBlock || '';
    return { title, source, ingredients, steps, servings, notes };
  }

  function commitAdditionsToBlack(){
    // unwrap .added spans into plain text nodes (so they render black)
    const added = editor.querySelectorAll('.added');
    added.forEach(span=>{
      span.replaceWith(document.createTextNode(span.textContent));
    });
  }

  saveBtn.addEventListener('click', ()=>{
    saveBtn.disabled = true;
    revertBtn.disabled = true;

    // 1) shimmer
    editor.classList.add('saving');

    // 2) commit .added → black (unwrap spans)
    commitAdditionsToBlack();

    // 3) collect final text + parse
    const finalText = editorToText();
    const parsed = parseStructured(finalText);

    // 4) save into Cookbook
    const nowISO = new Date().toISOString();
    const rec = {
      id: recipe.id && recipe.id.startsWith('r_') ? recipe.id : 'r_'+Date.now()+'_'+Math.random().toString(36).slice(2,7),
      createdAt: recipe.createdAt || nowISO,
      ...recipe,     // keep any original fields (e.g., source if missing)
      ...parsed,     // overwrite with parsed edits
    };
    const items = loadCookbook();
    const idxById = items.findIndex(x => x.id === rec.id);
    const idxByTitle = items.findIndex(x => x.title.toLowerCase() === rec.title.toLowerCase());

    if (idxById >= 0) {
      items[idxById] = rec;
    } else if (idxByTitle >= 0) {
      rec.id = items[idxByTitle].id; // keep stable id
      items[idxByTitle] = rec;
    } else {
      items.unshift(rec);
    }
    saveCookbook(items);

    // 5) done → brief status + clear shimmer + re-enable
    statusEl.textContent = 'Saved to your cookbook.';
    setTimeout(()=> {
      editor.classList.remove('saving');
      saveBtn.disabled = false;
      revertBtn.disabled = false;
    }, 750);
  });

  /* ---------- Revert to original ----------
     Behavior:
     - If there are .added spans (unsaved edits), keep them blue for ~300ms, then reset.
     - If there aren’t any (e.g., you saved already), tint the whole text blue briefly, then reset.
  */
  revertBtn.addEventListener('click', ()=>{
    saveBtn.disabled = true;
    revertBtn.disabled = true;

    const hasAdded = !!editor.querySelector('.added');

    if (hasAdded) {
      // they’re already blue — just give a tiny pause so you notice, then reset
      setTimeout(()=> {
        editor.innerHTML = ORIGINAL_HTML;  // full restore
        statusEl.textContent = 'Reverted to original.';
        setTimeout(()=> statusEl.textContent = '', 1000);
        saveBtn.disabled = false;
        revertBtn.disabled = false;
      }, 320);
    } else {
      // no .added spans (e.g., after save) — tint all text blue briefly, then restore
      editor.classList.add('revert-all');
      setTimeout(()=> {
        editor.classList.remove('revert-all');
        editor.innerHTML = ORIGINAL_HTML;
        statusEl.textContent = 'Reverted to original.';
        setTimeout(()=> statusEl.textContent = '', 1000);
        saveBtn.disabled = false;
        revertBtn.disabled = false;
      }, 320);
    }
  });

})();
</script>
</body>
</html>
